let s:assert = themis#helper('assert')
call themis#helper('command').with(s:assert)
call themis#func_alias(s:assert)

Describe :Macro
  Before all
    function Macro(args) abort
      execute 'Macro' a:args
      call feedkeys('', 'x')
    endfunction
  End

  Before each
    let @q = ''

    " Make '--check-continue' off in default while running tests.
    let g:litedit_opts = { 'macro': { 'check_continue': v:false } }

    %bwipeout!
  End

  After all
    let @q = ''
    %bwipeout!
    delfunction Macro
  End

  It write given command to default register.
    call Macro('abc')
    Assert Match(@q, '^abc')
  End

  It runs specified command in default.
    call setline(1, ["abc", "def"])
    call Macro('ciwf(<C-r>")<ESC>j')
    Assert Equals(getline(1, '$'), ["f(abc)", "f(def)"])
  End

  It is robust for complicated angle brackets.
    call setline(1, ["abc", "def"])
    call Macro('ciwf<<C-r>"><ESC>j')
    Assert Equals(getline(1, '$'), ['f<abc>', 'f<def>'])
  End

  It accepts whitespace at the head of command.
    call Macro('<Space> xxx')
    Assert Match(@q, '^  xxx')
  End

  Context no-recursive
    Before each
      let g:litedit_opts.macro.rec = v:false
    End

    It executes given command only once.
      call setline(1, ["abc", "def"])
      call Macro('ciwf(<C-r>")<ESC>j')
      Assert Equals(getline(1, '$'), ["f(abc)", "def"])
    End
  End

  Context no-exec
    Before each
      let g:litedit_opts.macro.exec = v:false
    End

    It does not run given command automatically.
      call setline(1, ["abc", "def"])
      call Macro('ciwf(<C-r>")<ESC>j')
      Assert Equals(getline(1, '$'), ["abc", "def"])
      Assert NotEquals(@q, '')
    End
  End

  Context explicitly specify register to use
    Before each
      let @x = ''
    End

    After all
      let @x = ''
    End

    It uses specified register.
      call setline(1, ["abc", "def"])
      call Macro('--reg x ciwf(<C-r>")<ESC>j')
      Assert Equals(getline(1, '$'), ["f(abc)", "f(def)"])
      Assert Equals(@q, '')
      Assert Match(@x, '@x$')
    End

    It uses the register specified in "@x" format.
      call setline(1, ["abc", "def"])
      call Macro('--reg @x ciwf(<C-r>")<ESC>j')
      Assert Equals(getline(1, '$'), ["f(abc)", "f(def)"])
      Assert Equals(@q, '')
      Assert Match(@x, '@x$')
    End

  End

  Context enable check-continue option
    Before all
      function SetAnswer(ans) abort
        augroup test-litedit
          autocmd!
          execute $'autocmd CmdlineEnter @ ++once call feedkeys("{a:ans}\<CR>", "ni")'
        augroup END
      endfunction
      command! -nargs=1 SetAnswer call SetAnswer(<q-args>)
    End

    After all
      delcommand SetAnswer
      delfunction SetAnswer
      augroup! test-litedit
    End

    Before each
      let g:litedit_opts.macro.check_continue = v:true
      let g:litedit_opts.macro.exec = v:true
      let g:litedit_opts.macro.rec = v:true
    End

    After each
      autocmd! test-litedit
    End

    Context check timing of dialog
      Before each
        let g:log_state = []
      End

      After all
        unlet g:log_state
      End

      It shows dialog after the first try of macro.
        call setline(1, ["abc", "def"])
        SetAnswer y

        call Macro('^xxj<Cmd>call add(g:log_state, getline(1, "$"))<CR>')
        Assert NotEmpty(g:log_state)
        Assert Equals(g:log_state[0], ['c', 'def'])
      End
    End

    It continues running when the answer is yes.
      call setline(1, ["abc", "def"])
      SetAnswer y

      call Macro('^xxj')
      Assert Equals(getline(1, '$'), ["c", "f"])
    End

    It cancels running when the answer is no.
      call setline(1, ["abc", "def"])
      SetAnswer n

      call Macro('^xxj')
      Assert Equals(getline(1, '$'), ["c", "def"])
    End

    It does not break macro content for <XXX> keys.
      call setline(1, ['abc', 'def', 'ghi'])
      SetAnswer y

      call Macro('ciwf<<C-r>"><ESC>j')
      Assert Equals(getline(1, '$'), ['f<abc>', 'f<def>', 'f<ghi>'])
    End

    It's dialog is not shown when '--rec' is off.
      let g:litedit_opts.macro.rec = v:false
      SetAnswer y

      call Macro('iabc<ESC>')

      const autocmds = execute('autocmd test-litedit CmdlineEnter')->split("\n")
      Assert Equals(len(autocmds), 3, autocmds)
    End

  End

End
